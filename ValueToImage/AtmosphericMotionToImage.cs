using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Media.Imaging;
using WorldCreaterStudio_Core.BackendNode.AtmosphericMotion;

namespace ValueToImage {
	/// <summary>
	/// 配合AtmosphericMotion的值转换器
	/// </summary>
	public static class AtmosphericMotionToImage {
		/// <summary>
		/// 获取区域风向图
		/// </summary>
		/// <param name="datas">风向数据</param>
		/// <returns></returns>
		public static WriteableBitmap GetBitmap (PointData[,] datas) {
			int width = datas.GetLength (1);
			int height = datas.GetLength (0);

			System.Windows.Media.Color[] colors = new System.Windows.Media.Color[2];
			colors[0] = new System.Windows.Media.Color () { A = 0, G = 0, R = 0, B = 0 };
			colors[1] = new System.Windows.Media.Color () { A = 255, G = 255, R = 255, B = 255 };

			BitmapPalette palette = new BitmapPalette (colors);
			WriteableBitmap re = new WriteableBitmap (width, height, 96, 96, System.Windows.Media.PixelFormats.Indexed1, palette);

			int wbn = width / 16;
			int hbn = height / 16;
			if (width % 16 != 0) wbn++;
			if (height % 16 != 0) hbn++;

			int[,,] qz = new int[hbn, wbn, 10];
			qz.Initialize ();

			// 累计
			for (int h = 0; h < height; h++) {
				for (int w = 0; w < width; w++) {
					PointData data = datas[h, w];
					qz[h / 16, w / 16, (int)data.direction] += data.power;
					qz[h / 16, w / 16, 9]++;
				}
			}

			// 计算 绘图
			for (int h = 0; h < hbn; h++) {
				for (int w = 0; w < wbn; w++) {
					double wde = 0, wdn = 0;
					qz[h, w, 1] -= qz[h, w, 5];
					qz[h, w, 2] -= qz[h, w, 6];
					qz[h, w, 3] -= qz[h, w, 7];
					qz[h, w, 4] -= qz[h, w, 8];

					wde = (qz[h, w, 3] - qz[h, w, 1]) * 0.70710678118654752440084436210485 + qz[h, w, 4];
					wdn = (qz[h, w, 1] + qz[h, w, 3]) * 0.70710678118654752440084436210485 + qz[h, w, 2];

					wde /= qz[h, w, 9];
					wdn /= qz[h, w, 9];

					// 笛卡尔转极坐标
					double r, coss, s;
					r = Math.Sqrt (wde * wde + wdn * wdn);
					coss = wde / r;
					if (wdn > 0) {
						s = Math.Acos (coss) * 180 / Math.PI;
					}
					else {
						s = 360 - Math.Acos (coss) * 180 / Math.PI;
					}

					// 绘图
					int rdpower = 0, rddire = 0;
					if (r > 160) { rdpower = 8; }
					else { rdpower = (int)r / 20; }
					
					if (rdpower < 1) { rddire = 0; }
					else {
						int tmp = ((int)((s + 22.5) % 360)) / 45;
						rddire = (byte)((11 - tmp) % 8 + 1);
					}


					re.WritePixels (new System.Windows.Int32Rect (w * 16, h * 16, 16, 16), SignData[rddire, rdpower], 2, 0);
				}

			}

			return re;
		}
		/// <summary>
		/// 索引分别为方向、风力、数组
		/// </summary>
		private static byte[,][] SignData = new byte[9, 9][];

		static AtmosphericMotionToImage () {
			//p0
			byte[] p0 = new byte[32] {
				0x00,0x00,
				0x00,0x00,
				0x00,0x00,
				0x00,0x00,

				0x00,0x00,
				0x00,0x00,
				0x00,0x80,
				0x01,0x90,

				0x03,0xE0,
				0x01,0x90,
				0x00,0x80,
				0x00,0x00,

				0x00,0x00,
				0x00,0x00,
				0x00,0x00,
				0x00,0x00
			};
			for (int i = 0; i < 9; i++) { SignData[0, i] = p0; }
			for (int i = 0; i < 9; i++) { SignData[i, 0] = p0; }

			#region 直向
			// 1 ========
			SignData[6, 1] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[8, 1] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF8, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[2, 1] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x01, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[4, 1] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x1F, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			// 2 ========
			SignData[6, 2] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xE0, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[8, 2] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF8, 0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[2, 2] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x07, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[4, 2] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x1F, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			// 3 ========
			SignData[6, 3] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xE0, 0x02, 0x00, 0x03, 0x80, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[8, 3] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF8, 0x00, 0x28, 0x00, 0x28, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[2, 3] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x01, 0xC0, 0x00, 0x40, 0x07, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[4, 3] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x14, 0x00, 0x14, 0x00, 0x1F, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			// 4 ========
			SignData[6, 4] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xE0, 0x02, 0x00, 0x03, 0xE0, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[8, 4] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF8, 0x00, 0x28, 0x00, 0x28, 0x00, 0x28, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[2, 4] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x07, 0xC0, 0x00, 0x40, 0x07, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[4, 4] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x1F, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			// 5 ========
			SignData[6, 5] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xE0, 0x02, 0x00, 0x03, 0xE0, 0x02, 0x00, 0x03, 0x80, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[8, 5] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF8, 0x00, 0xA8, 0x00, 0xA8, 0x00, 0x28, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[2, 5] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x01, 0xC0, 0x00, 0x40, 0x07, 0xC0, 0x00, 0x40, 0x07, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[4, 5] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x14, 0x00, 0x15, 0x00, 0x15, 0x00, 0x1F, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			// 6 ========
			SignData[6, 6] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xE0, 0x02, 0x00, 0x03, 0xE0, 0x02, 0x00, 0x03, 0xE0, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[8, 6] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF8, 0x00, 0xA8, 0x00, 0xA8, 0x00, 0xA8, 0x00, 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[2, 6] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x07, 0xC0, 0x00, 0x40, 0x07, 0xC0, 0x00, 0x40, 0x07, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[4, 6] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x1F, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			// 7 ========
			SignData[6, 7] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xE0, 0x02, 0x00, 0x03, 0xE0, 0x02, 0x00, 0x03, 0xE0, 0x02, 0x00, 0x03, 0x80, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[8, 7] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF8, 0x02, 0xA8, 0x02, 0xA8, 0x00, 0xA8, 0x00, 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[2, 7] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x01, 0xC0, 0x00, 0x40, 0x07, 0xC0, 0x00, 0x40, 0x07, 0xC0, 0x00, 0x40, 0x07, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[4, 7] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x40, 0x15, 0x40, 0x1F, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			// 8 ========
			SignData[6, 8] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x02, 0xC0, 0x02, 0x30, 0x02, 0xC0, 0x03, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[8, 8] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF8, 0x00, 0x88, 0x00, 0x50, 0x00, 0x50, 0x00, 0x20, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[2, 8] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0xC0, 0x03, 0x40, 0x0C, 0x40, 0x03, 0x40, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[4, 8] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x04, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x11, 0x00, 0x1F, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			#endregion

			#region 斜向
			// 1 ========
			SignData[5, 1] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08, 0x00, 0x04, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x80, 0x00, 0x40, 0x00, 0x20, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00 };
			SignData[7, 1] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0xA0, 0x01, 0x00, 0x02, 0x00, 0x04, 0x00, 0x08, 0x00, 0x10, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[1, 1] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x04, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x80, 0x00, 0x40, 0x00, 0x20, 0x00, 0x10, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[3, 1] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08, 0x00, 0x10, 0x00, 0x20, 0x00, 0x40, 0x00, 0x80, 0x05, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			// 2 ========
			SignData[5, 2] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x04, 0x00, 0x08, 0x00, 0x04, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x80, 0x00, 0x40, 0x00, 0x20, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00 };
			SignData[7, 2] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0xA0, 0x01, 0x10, 0x02, 0x08, 0x04, 0x00, 0x08, 0x00, 0x10, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[1, 2] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x04, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x80, 0x00, 0x40, 0x00, 0x20, 0x00, 0x10, 0x00, 0x20, 0x00, 0x40, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[3, 2] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08, 0x00, 0x10, 0x00, 0x20, 0x10, 0x40, 0x08, 0x80, 0x05, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			// 3 ========
			SignData[5, 3] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x04, 0x00, 0x09, 0x00, 0x06, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x80, 0x00, 0x40, 0x00, 0x20, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00 };
			SignData[7, 3] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0xA0, 0x01, 0x90, 0x02, 0x48, 0x04, 0x00, 0x08, 0x00, 0x10, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[1, 3] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x04, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x80, 0x00, 0x40, 0x00, 0x60, 0x00, 0x90, 0x00, 0x20, 0x00, 0x40, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[3, 3] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08, 0x00, 0x10, 0x00, 0x20, 0x12, 0x40, 0x09, 0x80, 0x05, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			// 4 ========
			SignData[5, 4] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x40, 0x04, 0x80, 0x09, 0x00, 0x06, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x80, 0x00, 0x40, 0x00, 0x20, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00 };
			SignData[7, 4] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0xA0, 0x01, 0x90, 0x02, 0x48, 0x04, 0x20, 0x08, 0x10, 0x10, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[1, 4] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x04, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x80, 0x00, 0x40, 0x00, 0x60, 0x00, 0x90, 0x01, 0x20, 0x02, 0x40, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[3, 4] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08, 0x08, 0x10, 0x04, 0x20, 0x12, 0x40, 0x09, 0x80, 0x05, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			// 5 ========
			SignData[5, 5] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x40, 0x04, 0x80, 0x09, 0x00, 0x06, 0x00, 0x02, 0x80, 0x01, 0x00, 0x00, 0x80, 0x00, 0x40, 0x00, 0x20, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00 };
			SignData[7, 5] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0xA0, 0x01, 0x90, 0x02, 0x48, 0x05, 0x20, 0x08, 0x10, 0x10, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[1, 5] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x04, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x80, 0x01, 0x40, 0x00, 0x60, 0x00, 0x90, 0x01, 0x20, 0x02, 0x40, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[3, 5] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08, 0x08, 0x10, 0x04, 0xA0, 0x12, 0x40, 0x09, 0x80, 0x05, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			// 6 ========
			SignData[5, 6] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x40, 0x04, 0x80, 0x09, 0x20, 0x06, 0x40, 0x02, 0x80, 0x01, 0x00, 0x00, 0x80, 0x00, 0x40, 0x00, 0x20, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00 };
			SignData[7, 6] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0xA0, 0x01, 0x90, 0x02, 0x48, 0x05, 0x20, 0x08, 0x90, 0x10, 0x40, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[1, 6] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x04, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x80, 0x01, 0x40, 0x02, 0x60, 0x04, 0x90, 0x01, 0x20, 0x02, 0x40, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[3, 6] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x02, 0x08, 0x09, 0x10, 0x04, 0xA0, 0x12, 0x40, 0x09, 0x80, 0x05, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			// 7 ========
			SignData[5, 7] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x40, 0x04, 0x80, 0x09, 0x20, 0x06, 0x40, 0x02, 0x80, 0x01, 0x20, 0x00, 0xC0, 0x00, 0x40, 0x00, 0x20, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00 };
			SignData[7, 7] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0xA0, 0x01, 0x90, 0x02, 0x48, 0x05, 0x20, 0x0C, 0x90, 0x12, 0x40, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[1, 7] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x04, 0x00, 0x02, 0x00, 0x03, 0x00, 0x04, 0x80, 0x01, 0x40, 0x02, 0x60, 0x04, 0x90, 0x01, 0x20, 0x02, 0x40, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[3, 7] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x02, 0x48, 0x09, 0x30, 0x04, 0xA0, 0x12, 0x40, 0x09, 0x80, 0x05, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			// 8 ========
			SignData[5, 8] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x06, 0x40, 0x08, 0x40, 0x04, 0x80, 0x02, 0x80, 0x01, 0x00, 0x00, 0x80, 0x00, 0x40, 0x00, 0x20, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00 };
			SignData[7, 8] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0xA0, 0x01, 0x20, 0x02, 0x10, 0x05, 0x90, 0x08, 0x70, 0x10, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[1, 8] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x04, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x80, 0x01, 0x40, 0x01, 0x20, 0x02, 0x10, 0x02, 0x60, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
			SignData[3, 8] = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08, 0x0E, 0x10, 0x09, 0xA0, 0x08, 0x40, 0x04, 0x80, 0x05, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

			#endregion
		}

		private static WriteableBitmap GetBGImgGBRA32 (BitmapImage baseImage) {
			if (baseImage.Format != System.Windows.Media.PixelFormats.Bgr32) return null;

			int mapheight = baseImage.PixelHeight;
			int mapwidth = baseImage.PixelWidth;

			WriteableBitmap re = new WriteableBitmap (mapwidth, mapheight, baseImage.DpiX, baseImage.DpiY, System.Windows.Media.PixelFormats.Rgb24, null);

			byte[] buffer = new byte[mapwidth * 4];
			//复制图像
			for (int h = 0; h < mapheight; h++) {
				System.Windows.Int32Rect rect = new System.Windows.Int32Rect (0, h, mapwidth, 1);
				baseImage.CopyPixels (rect, buffer, mapwidth * 4, 0);

				for (int w = 1; w < mapwidth; w++) {
					buffer[w * 3] = buffer[w * 4];
					buffer[w * 3 + 1] = buffer[w * 4 + 1];
					buffer[w * 3 + 2] = buffer[w * 4 + 2];

				}

				re.WritePixels (rect, buffer, mapwidth * 3, 0);
			}

			return re;
		}

		private static WriteableBitmap GetBGImgBGR24 (BitmapImage baseImage) {
			if (baseImage.Format != System.Windows.Media.PixelFormats.Bgr24) return null;

			int mapheight = baseImage.PixelHeight;
			int mapwidth = baseImage.PixelWidth;

			WriteableBitmap re = new WriteableBitmap (mapwidth, mapheight, baseImage.DpiX, baseImage.DpiY, System.Windows.Media.PixelFormats.Rgb24, null);

			byte[] buffer = new byte[mapwidth * 3];
			//复制图像
			for (int h = 0; h < mapheight; h++) {
				System.Windows.Int32Rect rect = new System.Windows.Int32Rect (0, h, mapwidth, 1);
				baseImage.CopyPixels (rect, buffer, mapwidth * 3, 0);

				re.WritePixels (rect, buffer, mapwidth * 3, 0);
			}

			return re;
		}

		private static WriteableBitmap GetBGImgGray8 (BitmapImage baseImage) {
			if (baseImage.Format != System.Windows.Media.PixelFormats.Gray8) return null;
			int mapheight = baseImage.PixelHeight;
			int mapwidth = baseImage.PixelWidth;

			WriteableBitmap re = new WriteableBitmap (mapwidth, mapheight, baseImage.DpiX, baseImage.DpiY, System.Windows.Media.PixelFormats.Rgb24, null);

			byte[] buffer = new byte[mapwidth * 3];
			//复制图像
			for (int h = 0; h < mapheight; h++) {
				System.Windows.Int32Rect rect = new System.Windows.Int32Rect (0, h, mapwidth, 1);
				baseImage.CopyPixels (rect, buffer, mapwidth, 0);
				for (int w = mapwidth - 1; w >= 0; w--) {
					buffer[w * 3] = buffer[w * 3 + 1] = buffer[w * 3 + 2] = buffer[w];
				}
				re.WritePixels (rect, buffer, mapwidth * 3, 0);
			}

			return re;
		}

		private static WriteableBitmap GetBGImgIndex8 (BitmapImage baseImage) {
			if (baseImage.Format != System.Windows.Media.PixelFormats.Indexed8) return null;
			int mapheight = baseImage.PixelHeight;
			int mapwidth = baseImage.PixelWidth;

			WriteableBitmap re = new WriteableBitmap (mapwidth, mapheight, baseImage.DpiX, baseImage.DpiY, System.Windows.Media.PixelFormats.Bgr24, null);
			var colors = baseImage.Palette.Colors;

			byte[] buffer = new byte[mapwidth * 3];
			//复制图像
			for (int h = 0; h < mapheight; h++) {
				System.Windows.Int32Rect rect = new System.Windows.Int32Rect (0, h, mapwidth, 1);
				baseImage.CopyPixels (rect, buffer, mapwidth, 0);
				for (int w = mapwidth - 1; w >= 0; w--) {
					byte index = buffer[w];
					buffer[w * 3] = colors[index].B;
					buffer[w * 3 + 1] = colors[index].G;
					buffer[w * 3 + 2] = colors[index].R;
				}
				re.WritePixels (rect, buffer, mapwidth * 3, 0);
			}

			return re;
		}
	}
}
